/**
 * @file script.cc
 *
 * Copyright (c) 2010-2018 Neto Ranito & Seabra LDA. All rights reserved.
 *
 * This file is part of casper-connectors.
 *
 * casper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * casper  is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with casper.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "cc/v8/script.h"

#include "cc/v8/singleton.h"

#include "cc/v8/exception.h"

#include "cc/utc_time.h"

/**
 * @brief Constructor.
 *
 * @param a_owner
 * @param a_name
 * @param a_uri
 * @param a_out_path
 * @param a_functions
 */
cc::v8::Script::Script (const std::string& a_owner, const std::string& a_name, const std::string& a_uri,
                        const std::string& a_out_path,
                        const cc::v8::Script::NativeFunctions& a_functions
)
    : owner_(a_owner), name_(a_name), uri_(a_uri), out_path_(a_out_path),
      context_(cc::v8::Singleton::GetInstance().isolate(), a_functions),
      cancelled_(false)
{
    /* empty */
}

/**
 * @brief Destructor.
 */
cc::v8::Script::~Script ()
{
    /* empty */
}

/**
 * @brief Compile a script
 *
 * @param a_script
 * @param a_functions
 */
void cc::v8::Script::Compile (const ::v8::Local<::v8::String>& a_script, const cc::v8::Script::FunctionsVector* a_functions)
{
    const ::v8::String::Utf8Value& script = ::v8::String::Utf8Value(context_.Isolate(), a_script);

    const std::string log_uri = out_path_ + name_ + ".js";

    std::ofstream out(log_uri, std::ofstream::out);
    if ( ! out ) {
        throw cc::v8::Exception("Failed to write data to '%s'!", log_uri.c_str());
    }
    out << "//\n// " << name_ << " \n";
    out << "//\n// Generated by " << owner_ << "\n";
    out << "//\n// Based on " << uri_ << "\n";
    out << "//\n// " << ::cc::UTCTime::NowISO8601WithTZ() << "\n";
    out << "//\n\n";
    out << *script;

    const auto start_tp = std::chrono::high_resolution_clock::now();

    context_.Compile(name_, a_script, a_functions);

    const auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - start_tp ).count();

    out << "\n\n//\n// Elapsed " << elapsed << " microseconds / " << ( (float)elapsed / 1000.0f ) << " milliseconds\n";
    out << "//\n";

    out.close();
}

#ifdef __APPLE__
#pragma mark -
#endif

/**
 * @brief Translate a V8 value to a Value.
 *
 * @param a_isolate
 * @param a_value
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateFromV8Value (::v8::Isolate* a_isolate, const ::v8::Persistent<::v8::Value>& a_value, Value& o_value) const
{
    const ::v8::Local<::v8::Value> value = a_value.Get(a_isolate);
    
    if ( true == value.IsEmpty() ) {
        o_value.SetNull();
    } else if ( true == value->IsString() ) {
        const ::v8::String::Utf8Value& string = ::v8::String::Utf8Value(a_isolate, value);
        if ( nullptr != *string ) {
            o_value = (*string);
        } else {
            o_value.SetNull();
        }
    } else if ( true == value->IsBoolean() ) {
        o_value = value->BooleanValue(a_isolate);
    } else if ( true == value->IsNumber() ) {
        if ( true == value->IsInt32() ) {
            o_value = value->NumberValue(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else if ( true == value->IsUint32() ) {
            o_value = value->NumberValue(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else {
            o_value = value->NumberValue(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        }
    } else { // true == value->IsNull() || true == value->IsUndefined() || ...
        o_value.SetNull();
    }
}

/**
 * @brief Translate a value to a V8 Value.
 *
 * @param a_isolate
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateToV8Value (::v8::Isolate* a_isolate, const cc::v8::Value& a_value, ::v8::Local<::v8::Value>& o_value) const
{
    switch (a_value.type()) {
        case cc::v8::Value::Type::Int32:
            o_value = ::v8::Int32::New(a_isolate, (const int32_t)(a_value));
            break;
        case cc::v8::Value::Type::UInt32:
            o_value = ::v8::Uint32::New(a_isolate, (const uint32_t)(a_value));
            break;
        case cc::v8::Value::Type::Double:
            o_value = ::v8::Number::New(a_isolate, (const double)(a_value));
            break;
        case cc::v8::Value::Type::String:
            o_value = ::v8::String::NewFromUtf8(a_isolate, (const char* const)(a_value), ::v8::NewStringType::kNormal).ToLocalChecked();
            break;
        case cc::v8::Value::Type::Boolean:
            o_value = ::v8::Boolean::New(a_isolate, (const bool)(a_value));
            break;
        default:
            o_value = ::v8::Null(a_isolate);
            break;
    }
}
