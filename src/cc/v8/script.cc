/**
 * @file script.cc
 *
 * Copyright (c) 2010-2018 Neto Ranito & Seabra LDA. All rights reserved.
 *
 * This file is part of casper-connectors.
 *
 * casper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * casper  is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with casper.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "cc/v8/script.h"

#include "cc/v8/singleton.h"

#include "cc/v8/exception.h"

#include "cc/utc_time.h"

#include "json/json.h"

/**
 * @brief Constructor.
 *
 * @param a_owner
 * @param a_name
 * @param a_uri
 * @param a_out_path
 * @param a_functions
 */
cc::v8::Script::Script (const std::string& a_owner, const std::string& a_name, const std::string& a_uri,
                        const std::string& a_out_path,
                        const cc::v8::Script::NativeFunctions& a_functions
)
    : owner_(a_owner), name_(a_name), uri_(a_uri), out_path_(a_out_path),
      context_(cc::v8::Singleton::GetInstance().isolate(), a_functions),
      cancelled_(false)
{
    /* empty */
}

/**
 * @brief Destructor.
 */
cc::v8::Script::~Script ()
{
    /* empty */
}

// MARK: -

/**
 * @brief   Patch a JSON object, by calling a function if an expressions is found.
 *
 * @param a_value    JSON Object.
 * @param a_callback Function to call when an expression is found.
 */
void cc::v8::Script::PatchObject (Json::Value& a_object, const std::function<Json::Value(const std::string& a_expression)>& a_callback) const
{
     switch ( a_object.type() ) {
        case Json::ValueType::objectValue:   // object value (collection of name/value pairs)
            for( auto member : a_object.getMemberNames()) {
                PatchObject(a_object[member], a_callback);
            }
            break;
        case Json::ValueType::arrayValue:    // array value (ordered list)
            for ( auto ait = a_object.begin(); ait != a_object.end(); ++ait ) {
                PatchObject(*ait, a_callback);
            }
            break;
        case Json::ValueType::stringValue:   // UTF-8 string value
            if ( nullptr != strstr(a_object.asCString(), "$.") || nullptr != strstr(a_object.asCString(), "$[" ) ) {
                a_object = a_callback(a_object.asString());
            }
            break;
        case Json::ValueType::nullValue:    // 'null' value
        case Json::ValueType::intValue:     // signed integer value
        case Json::ValueType::uintValue:    // unsigned integer value
        case Json::ValueType::realValue:    // double value
        case Json::ValueType::booleanValue: // bool value
        default:
            break;
    }
}

// MARK: -

/**
 * @brief Compile a script
 *
 * @param a_script     Script to compile.
 * @param a_functions  Native functions to load.
 * @param o_data       When set, script will be outputed to a string instead to a file.
 */
void cc::v8::Script::Compile (const ::v8::Local<::v8::String>& a_script, const cc::v8::Script::FunctionsVector* a_functions, std::string* o_data)
{
    const ::v8::String::Utf8Value& script = ::v8::String::Utf8Value(context_.Isolate(), a_script);

    std::stringstream ss;
    
    ss << "//\n// " << name_ << " \n";
    ss << "//\n// Generated by " << owner_ << "\n";
    ss << "//\n// Based on " << uri_ << "\n";
    ss << "//\n// " << ::cc::UTCTime::NowISO8601WithTZ() << "\n";
    ss << "//\n\n";
    ss << *script;
    
    const std::string uri = out_path_ + name_ + ".js";
    
    const auto dump = [o_data, &uri] (std::stringstream& a_ss) {
        if ( nullptr != o_data ) {
            (*o_data) = a_ss.str();
        } else {
            std::ofstream out(uri, std::ofstream::out);
            if ( ! out ) {
                throw cc::v8::Exception("Failed to write data to '%s'!", uri.c_str());
            }
            out << a_ss.str();
            out.close();
        }
    };

    const auto start_tp = std::chrono::high_resolution_clock::now();
    try {
        context_.Compile(uri, a_script, a_functions);
        // ...
        const auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - start_tp ).count();
        // ... sucesss ...
        ss << "\n\n//\n// Compiled in " << elapsed << " microseconds / " << ( (float)elapsed / 1000.0f ) << " milliseconds\n";
        ss << "//\n";
        // ... dump ...
        dump(ss);
    } catch (const ::cc::v8::Exception& a_v8_exception) {
        // ...
        ss << "\n\n//\n// FAILED TO COMPILE!\n";
        ss << a_v8_exception.what() << "\n";
        ss << "//\n";
        // ... dump ...
        dump(ss);
        // ... re-throw ...
        throw a_v8_exception;
    }
}

#ifdef __APPLE__
#pragma mark -
#endif

/**
 * @brief Translate a V8 value to a Value.
 *
 * @param a_isolate
 * @param a_value
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateFromV8Value (::v8::Isolate* a_isolate, const ::v8::Persistent<::v8::Value>& a_value, Value& o_value) const
{
    const ::v8::Local<::v8::Value> value = a_value.Get(a_isolate);
    
    if ( true == value.IsEmpty() ) {
        o_value.SetNull();
    } else if ( true == value->IsString() ) {
        const ::v8::String::Utf8Value& string = ::v8::String::Utf8Value(a_isolate, value);
        if ( nullptr != *string ) {
            o_value = (*string);
        } else {
            o_value.SetNull();
        }
    } else if ( true == value->IsBoolean() ) {
        o_value = value->BooleanValue(a_isolate);
    } else if ( true == value->IsDate() ) {
        // TODO:
        // o_value.SetDate(value->NumberValue(a_isolate));
        CC_ASSERT(1 == 0);
    } else if ( true == value->IsNumber() ) {
        if ( true == value->IsInt32() ) {
            o_value = value->Int32Value(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else if ( true == value->IsUint32() ) {
            o_value = value->Uint32Value(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else {
            o_value = value->NumberValue(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        }
    } else if ( true == value->IsObject() ) {
        // TODO: check if there is better way to do this ...
        // ... convert an object
        ::v8::Local<::v8::String> local_string;
        if ( false == ::v8::JSON::Stringify(a_isolate->GetCurrentContext(), value).ToLocal(&local_string) ) {
            throw cc::v8::Exception("An error ocurred while translating a V8 object to a JSON object': %s!",
                                    "can't convert to a 'local' string"
            );
        }
        // ... parse it as JSON ...
        const ::v8::String::Utf8Value& utf8_string = ::v8::String::Utf8Value(a_isolate, local_string);
        try {
            Json::Reader reader;            
            Json::Value  val;
            if ( false == reader.parse((*utf8_string), val) ) {
                const auto errors = reader.getStructuredErrors();
                if ( errors.size() > 0 ) {
                    throw cc::v8::Exception("An error ocurred while translating a V8 object to a JSON object': %s!",
                                            reader.getFormatedErrorMessages().c_str()
                    );
                } else {
                    throw cc::v8::Exception("%s",
                                            "An error ocurred while translating a V8 object to a JSON object!"
                    );
                }
            }
            o_value = val;
        } catch (const Json::Exception& a_json_exception ) {
            throw cc::v8::Exception("%s", a_json_exception.what());
        }
    } else { // true == value->IsNull() || true == value->IsUndefined() || ...
        o_value.SetNull();
    }
}

/**
 * @brief Translate a value to a V8 Value.
 *
 * @param a_isolate
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateToV8Value (::v8::Isolate* a_isolate, const cc::v8::Value& a_value, ::v8::Local<::v8::Value>& o_value) const
{
    switch (a_value.type()) {
        case cc::v8::Value::Type::Int32:
            o_value = ::v8::Int32::New(a_isolate, (const int32_t)(a_value));
            break;
        case cc::v8::Value::Type::UInt32:
            o_value = ::v8::Uint32::New(a_isolate, (const int32_t)(a_value));
            break;
        case cc::v8::Value::Type::Double:
            o_value = ::v8::Number::New(a_isolate, (const double)(a_value));
            break;
        case cc::v8::Value::Type::String:
            o_value = ::v8::String::NewFromUtf8(a_isolate, (const char* const)(a_value), ::v8::NewStringType::kNormal).ToLocalChecked();
            break;
        case cc::v8::Value::Type::Boolean:
            o_value = ::v8::Boolean::New(a_isolate, (const bool)(a_value));
            break;
        default:
            o_value = ::v8::Null(a_isolate);
            break;
    }
}
