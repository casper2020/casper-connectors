/**
 * @file script.cc
 *
 * Copyright (c) 2010-2018 Neto Ranito & Seabra LDA. All rights reserved.
 *
 * This file is part of casper-connectors.
 *
 * casper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * casper  is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with casper.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "cc/v8/script.h"

#include "cc/v8/singleton.h"

#include "cc/v8/exception.h"

#include "cc/utc_time.h"

#include "json/json.h"

/**
 * @brief Constructor.
 *
 * @param a_owner
 * @param a_name
 * @param a_uri
 * @param a_out_path
 * @param a_functions
 */
cc::v8::Script::Script (const std::string& a_owner, const std::string& a_name, const std::string& a_uri,
                        const std::string& a_out_path,
                        const cc::v8::Script::NativeFunctions& a_functions
)
    : owner_(a_owner), name_(a_name), uri_(a_uri), out_path_(a_out_path),
      context_(cc::v8::Singleton::GetInstance().isolate(), a_functions),
      cancelled_(false)
{
    /* empty */
}

/**
 * @brief Destructor.
 */
cc::v8::Script::~Script ()
{
    /* empty */
}

/**
 * @brief Compile a script
 *
 * @param a_script
 * @param a_functions
 */
void cc::v8::Script::Compile (const ::v8::Local<::v8::String>& a_script, const cc::v8::Script::FunctionsVector* a_functions)
{
    const ::v8::String::Utf8Value& script = ::v8::String::Utf8Value(context_.Isolate(), a_script);

    const std::string log_uri = out_path_ + name_ + ".js";

    std::ofstream out(log_uri, std::ofstream::out);
    if ( ! out ) {
        throw cc::v8::Exception("Failed to write data to '%s'!", log_uri.c_str());
    }
    
    out << "//\n// " << name_ << " \n";
    out << "//\n// Generated by " << owner_ << "\n";
    out << "//\n// Based on " << uri_ << "\n";
    out << "//\n// " << ::cc::UTCTime::NowISO8601WithTZ() << "\n";
    out << "//\n\n";
    out << *script;

    const auto start_tp = std::chrono::high_resolution_clock::now();

    context_.Compile(name_, a_script, a_functions);

    const auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - start_tp ).count();

    out << "\n\n//\n// Compiled in " << elapsed << " microseconds / " << ( (float)elapsed / 1000.0f ) << " milliseconds\n";
    out << "//\n";

    out.close();
}

#ifdef __APPLE__
#pragma mark -
#endif

/**
 * @brief Translate a V8 value to a Value.
 *
 * @param a_isolate
 * @param a_value
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateFromV8Value (::v8::Isolate* a_isolate, const ::v8::Persistent<::v8::Value>& a_value, Value& o_value) const
{
    const ::v8::Local<::v8::Value> value = a_value.Get(a_isolate);
    
    if ( true == value.IsEmpty() ) {
        o_value.SetNull();
    } else if ( true == value->IsString() ) {
        const ::v8::String::Utf8Value& string = ::v8::String::Utf8Value(a_isolate, value);
        if ( nullptr != *string ) {
            o_value = (*string);
        } else {
            o_value.SetNull();
        }
    } else if ( true == value->IsBoolean() ) {
        o_value = value->BooleanValue(a_isolate);
    } else if ( true == value->IsNumber() ) {
        if ( true == value->IsInt32() ) {
            o_value = value->Int32Value(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else if ( true == value->IsUint32() ) {
            o_value = value->Uint32Value(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        } else {
            o_value = value->NumberValue(a_isolate->GetCurrentContext()).FromMaybe(0.0);
        }
    } else if ( true == value->IsObject() ) {
        // TODO: check if there is better way to do this ...
        // ... convert an object
        ::v8::Local<::v8::String> local_string;
        if ( false == ::v8::JSON::Stringify(a_isolate->GetCurrentContext(), value).ToLocal(&local_string) ) {
            throw cc::v8::Exception("An error ocurred while translating a V8 object to a JSON object': %s!",
                                    "can't convert to a 'local' string"
            );
        }
        // ... parse it as JSON ...
        const ::v8::String::Utf8Value& utf8_string = ::v8::String::Utf8Value(a_isolate, local_string);
        try {
            Json::Reader reader;            
            Json::Value  value;
            if ( false == reader.parse((*utf8_string), value) ) {
                const auto errors = reader.getStructuredErrors();
                if ( errors.size() > 0 ) {
                    throw cc::v8::Exception("An error ocurred while translating a V8 object to a JSON object': %s!",
                                            reader.getFormatedErrorMessages().c_str()
                    );
                } else {
                    throw cc::v8::Exception("%s",
                                            "An error ocurred while translating a V8 object to a JSON object!"
                    );
                }
            }
            o_value = value;
        } catch (const Json::Exception& a_json_exception ) {
            throw cc::v8::Exception("%s", a_json_exception.what());
        }
    } else { // true == value->IsNull() || true == value->IsUndefined() || ...
        o_value.SetNull();
    }
}

/**
 * @brief Translate a value to a V8 Value.
 *
 * @param a_isolate
 * @param a_value
 *
 * @param o_value
 */
void cc::v8::Script::TranslateToV8Value (::v8::Isolate* a_isolate, const cc::v8::Value& a_value, ::v8::Local<::v8::Value>& o_value) const
{
    switch (a_value.type()) {
        case cc::v8::Value::Type::Int32:
            o_value = ::v8::Int32::New(a_isolate, (const int32_t)(a_value));
            break;
        case cc::v8::Value::Type::UInt32:
            o_value = ::v8::Uint32::New(a_isolate, (const uint32_t)(a_value));
            break;
        case cc::v8::Value::Type::Double:
            o_value = ::v8::Number::New(a_isolate, (const double)(a_value));
            break;
        case cc::v8::Value::Type::String:
            o_value = ::v8::String::NewFromUtf8(a_isolate, (const char* const)(a_value), ::v8::NewStringType::kNormal).ToLocalChecked();
            break;
        case cc::v8::Value::Type::Boolean:
            o_value = ::v8::Boolean::New(a_isolate, (const bool)(a_value));
            break;
        default:
            o_value = ::v8::Null(a_isolate);
            break;
    }
}
